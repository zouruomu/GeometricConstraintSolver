import numpy as np

class GeometricObject:
    """Abstract superclass defining a generic 3D geometric object with location, rotation, and scale.

    A GeometricObject is defined by its location in global cooridnates, rotation in Euler angles,
    and scale (all objects share the same scale). For all objects, location and z-rotation are 
    treated as optimizable, and scale is treated as fixed. To define a specific type of geometric 
    object (see class Cuboid below), the methods get_bounding_intervals and add_self_to_axis must be
    implemented. Sub-classes may have additional attributes.

    Attributes:
        loc: a length 3 np.array of form [loc_x, loc_y, loc_z].
        rot: a length 3 np.array of form [rot_x, rot_y, rot_z].
        scale: a length 3 np.array of form [scale_x, scale_y, scale_z].
        name: str, natural language name for the object.
    """
    def __init__(self, loc, rot, scale, name):
        """Init method.
        
        Args: 
            loc: list-like with form [X,Y,Z], object centroid coordinates.
            rot: list-like with form [X,Y,Z], object rotation in degrees.
            scale: list-like with form [X,Y,Z], object scale.
            name: str, natural language name for the object.
        Returns:
            None
        """
        self.loc = np.array(loc)
        self.rot = np.array(rot)
        self.scale = np.array(scale)
        self.name = name

    def __str__(self) -> str:
        """To string method.
        """
        return str(self.name)

    def get_all_attr(self):
        """Get all attributes in the form of a flat np.array.
        
        Args:
            None.
        Returns:
            A flat np.array with every optimizable attribute stacked together.
            It looks like [loc_x,loc_y,loc_z,rot_x,rot_y,rot_z,scale_x,scale_y,scale_z].
        """
        return np.concatenate([self.loc, self.rot, self.scale])

    def get_optimizable_attr(self):
        """Get the attributes that can be optimized in the form of a flat np.array.
        
        Generally, we assume location and z-rotation to be optimizable, and scale to be fixed.
        x and y rotation are assumed to be fixed.
        
        Args:
            None.
        Returns:
            A flat np.array with every optimizable attribute stacked together.
            It looks like [loc_x,loc_y,loc_z,rot_z].
        """
        return np.concatenate([self.loc[:2], self.rot[2:3]])

    def set_optimizable_attr(self, attr_array):
        """Set optimizable attributes with an np.array of the same form as one from get_optimizable_attr.

        The purpose of this method is to quickly convert an array generated by get_optimizable_attr and
        optimized by the scipy optimizer back to self.geometry.

        Args:
            attr_array: Flat np.array of same form as one returned by get_optimizable_attr.
        Returns:
            None. Modifies self.geometry.
        """
        self.loc[:2] = attr_array[:2]
        self.rot[2] = attr_array[2]

    def get_bounding_intervals(self):
        """Get the largest and lowest coordinate values along each dimension of the object as intervals.

        The purpose of this method is to easily get a "bounding box" in the form of three (along
        the X, Y, and Z axes) intervals that fully (and ideally tightly) bound the range of points
        spanned by the object. This way, regardless of the object's shape or orientation, we can
        get a cuboid bound that is always parallel to the global coordinate axes. Having this method
        makes constraints that rely on having the "leftmost" or "topmost" points aligned easier to write.

        Args:
            None.   
        Returns:
            A tuple of three lists ([x_min, x_max], [y_min, y_max], [z_min, z_max]) that bounds the object.
        """
        raise NotImplementedError

    def add_self_to_axis(self, ax, color):
        """Add self as a 3D wireframe shape with appropriate loc/rot/scale to an matplotlib axis.

        Args:
            ax: A matplotlib axis with projection set to 3D.
            color: A valid matplotlib color to use for this object's wireframe.
        Returns:
            A color patch with label to be passed to legend handler. Also modifies the input argument ax.
        """
        raise NotImplementedError